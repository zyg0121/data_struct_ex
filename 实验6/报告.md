# 数据结构第六次实验报告
201900800526周依果
# 需求与分析设计

## 第一部分
我们需要随机生成一个具有10个顶点的加权连通图，并用邻接表存储。同时用深度优先搜索或广度优先搜索方法遍历该图；

图的邻接表存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。如词条概念图所示，表结点存放的是邻接顶点在数组中的索引。对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。

邻接表是图的一种最主要存储结构,用来描述图上的每一个点。对图的每个顶点建立一个容器（n个顶点建立n个容器），第i个容器中的结点包含顶点Vi的所有邻接顶点。实际上我们常用的邻接矩阵就是一种未离散化每个点的边集的邻接表。

我们先规定好点的数量和边的数量，同时采用随机数来指定哪两个点进行连接以及这条边的权值，同时判断不要产生自环即可。

然后实现图的遍历，我们采用深度优先搜索。深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。

初始条件下所有节点为白色，选择一个作为起始顶点，按照如下步骤遍历：

1. 选择起始顶点涂成灰色，表示还未访问
2. 从该顶点的邻接顶点中选择一个，继续这个过程（即再寻找邻接结点的邻接结点），一直深入下去，直到一个顶点没有邻接结点了，涂黑它，表示访问过了
3. 回溯到这个涂黑顶点的上一层顶点，再找这个上一层顶点的其余邻接结点，继续如上操作，如果所有邻接结点往下都访问过了，就把自己涂黑，再回溯到更上一层。
4. 上一层继续做如上操作，知道所有顶点都访问过。

## 第二部分

建立图的部分同上，我们采用Kruskal算法实现最小生成树。Kruskal算法的思想比Prin好理解一些。先把边按照权值进行排序，用贪心的思想优先选取权值较小的边，并依次连接，若出现环则跳过此边（用并查集来判断是否存在环）继续搜，直到已经使用的边的数量比总点数少一即可。

如果某个连通图属于最小生成树，那么所有从外部连接到该连通图的边中的一条最短的边必然属于最小生成树。所以不难发现，当最小生成树被拆分成彼此独立的若干个连通分量的时候，所有能够连接任意两个连通分量的边中的一条最短边必然属于最小生成树。

## 第三部分

我们需要实现一颗基于学号为key的二叉排序树。

二叉排序树也叫做二叉查找树，它或者是一棵空树，或者是具有以下性质的二叉树：

1. 若它的左子树不为空，则左子树上所有结点的值均小于它的根结点的值
2. 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值
3. 它的左、右子树也分别为二叉排序树(递归的定义)

构造一棵二叉树的目的并不是为了排序，而是为了提高查找和插入、删除元素的速度，因为在一个有序的数据集上进行查找操作，速度肯定是快于无序的数据集的。

# 代码运行结果

## 第一部分
```shell
1 9 8 3 10 6 5 2 7 4
```
## 第二部分
```shell
edge:(9,7),weight = 6
edge:(2,6),weight = 8
edge:(9,2),weight = 11
edge:(9,4),weight = 13
edge:(1,8),weight = 15
edge:(9,1),weight = 17
edge:(10,9),weight = 23
edge:(3,10),weight = 29
edge:(3,5),weight = 31
ans = 153
```
## 第三部分
```shell
Please enter the number of student:
10
Please enter the id of the student:
1 2 3 4 5 6 7 8 9 10
Please enter the id who you want to find:
5
find successful
Please enter the id who you want to find:
11
can not find
```