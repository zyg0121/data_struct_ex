# 数据结构第二次实验

# 需求

在实验一中，我们把一栋两层的宿舍楼中各个宿舍抽象成一个个同类型的数据单元，并用类来进行封装，并用线性表这种数据结构的顺序存储模式存储管理。

这期间，我们发现了以物理存储单元之间的先后顺序来管理线性表的利弊。

所以，我们在完成线性表版本的程序设计后，需要对此进行时空优化，使其的效率更高。

现在，根据实验一，我们总结线性表的顺序存储管理模式在实现宿舍管理系统过程中存在的局限性和不便之处。并针对这些不足，选择单链表存储管理模式优化宿舍管理系统。
# 对实验一的利弊的分析

## 在空间上

1. 空间的开辟

顺序表的实现一般是实现连续开辟一段空间，然后在进行数据的增删查改（静态顺序表），所以顺序表一般是固定空间大小的；

而单链表则是一次只开辟一个结点的空间，用来存储当前要保存的数据及指向下一个结点或NULL的指针，所以单链表的空间大小是动态变化的。

当然，我们这里的顺序表是动态的，可以根据实际情况适当扩充，从而变相实现空间的动态变化。

2. 空间的使用

当我们不知道要存储多少数据时，用顺序表来开辟的空间如果太大，就会造成一定程度上的浪费，而用单链表是实现时，因为是每需要存储一个数据时，才开辟一个空间，虽然有非数据项的指针占空间，但相比顺序表来说，浪费不是那么明显；

反之，当我们知道存储的数据的数量时，用顺序表来开辟对应的空间大小，来存储数据，因为顺序表中每个元素的存储密度为1，就完全不会有浪费的空间。
而用单链表，因为每个结点都会有非数据项得指针，那么就会造成空间的浪费。

## 在时间上

1. 访问随机元素的时间复杂度

因为顺序表的结构就像是数组一样，可以用下标来访问它的元素，所以它的元素是支持随机访问的。

相比之下，单链表的数据是链式存储的，它的元素是不支持随机访问的，想要知道某个元素，只能从头结点开始遍历整个链表，知道找到了该元素为止。

因此顺序表访问随机元素的时间复杂度是O(1)，而单链表访问随机元素的平均时间复杂度是O(n)。


2. 随机位置插入、删除元素的时间复杂度

因为顺序表的元素是连续存储的，因此要在特定位置插入、删除元素需要把它之后的元素全部后移或前移一个元素的位置，时间开销很大。

而单链表在插入或删除元素时，只需要改变它的前驱元素及插入或删除元素的指向即可。

因此，顺序表在插入随机位置插入、删除元素的平均时间复杂度是O(n)，单链表在插入随机位置插入、删除元素的时间复杂度是O(1)。

# 对实验二的分析和设计

我们同实验一类似，将每间宿舍抽象成一个类，在类中，我们抽象设计了包括宿舍的房号、面积、人数、宿舍条件等信息，然后将抽象出来的类利用单链表进行操作，链表包括存储我们宿舍信息的类和其指向的下一个节点。可以进行增删查，输出和合并等操作。来完成我们的实验目的（增加一个宿舍信息，删除一个宿舍信息，输出整层楼的信息，通过位置查找一个宿舍信息，将两层楼的信息合并），另外对于实验中要求两层楼，我们仅需在主函数中声明两个链表分别存储即可。


# 程序运行方法和结果

对于运行方法，基本同线性表版本类似。

## 样例
对一楼我们设计有3间房
```
101 20 6 1
102 20 6 0
103 18 6 0
```
对二楼我们设计有2间房
```
201 15 4 1
202 15 4 0
```
## 执行程序
输入初始的1楼和2楼的宿舍信息（房号，面积，人数，条件(1/0)）。

![](https://i1.100024.xyz/i/2020/10/09/p670j9.png)

插入操作

![](https://i1.100024.xyz/i/2020/10/09/p7kp8l.png)

删除操作

![](https://i1.100024.xyz/i/2020/10/09/p7kxh6.png)

查找操作

![](https://i1.100024.xyz/i/2020/10/09/p7ktgg.png)

输出操作

![](https://i1.100024.xyz/i/2020/10/09/p7kvg2.png)

合并操作

![](https://i1.100024.xyz/i/2020/10/09/p7l389.png)

## 运行结果

对给定的样例，运行结果一切正常。

同时通过随机数进行大规模数据的测试，在每层楼有1k间房的情况下同样运行一切正常，在此不给出具体运行结果。

# 附

第一次实验没有经验，真的不知道要写些啥，所以看起来像随意写的，但实际上都是自己写的代码。

本实验作业在github上同步，地址如下：https://github.com/zyg0121/data_struct_ex